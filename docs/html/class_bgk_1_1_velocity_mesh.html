<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Plasma BGK: Bgk::VelocityMesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Plasma BGK<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_bgk_1_1_velocity_mesh.html','','class_bgk_1_1_velocity_mesh-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Bgk::VelocityMesh&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Bgk::VelocityMesh&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_bgk_1_1_velocity_mesh.png" usemap="#Bgk_3A_3AVelocityMesh_3C_20T_20_3E_map" alt=""/>
  <map id="Bgk_3A_3AVelocityMesh_3C_20T_20_3E_map" name="Bgk_3A_3AVelocityMesh_3C_20T_20_3E_map">
<area href="class_bgk_1_1_base_mesh1_d.html" alt="Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;" shape="rect" coords="0,0,389,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad04156f79751a5c40e272fc1b0164ac1" id="r_ad04156f79751a5c40e272fc1b0164ac1"><td class="memItemLeft" align="right" valign="top"><a id="ad04156f79751a5c40e272fc1b0164ac1" name="ad04156f79751a5c40e272fc1b0164ac1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VelocityMesh</b> (const <a class="el" href="class_bgk_1_1_config_data.html">ConfigData</a>&lt; T &gt; &amp;config)</td></tr>
<tr class="memitem:ac43786842224f451a3e4e0277082968f" id="r_ac43786842224f451a3e4e0277082968f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac43786842224f451a3e4e0277082968f">operator[]</a> (size_t index) const override</td></tr>
<tr class="memdesc:ac43786842224f451a3e4e0277082968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator to get the computational point at a specific index. Read only.  <br /></td></tr>
<tr class="memitem:ae4b70376cac02434c6d5670d7ee18dc2" id="r_ae4b70376cac02434c6d5670d7ee18dc2"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b70376cac02434c6d5670d7ee18dc2">operator[]</a> (size_t index) override</td></tr>
<tr class="memdesc:ae4b70376cac02434c6d5670d7ee18dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator to get the computational point at a specific index.  <br /></td></tr>
<tr class="memitem:a948581a3ee983f757ccba4f4d67a43c3" id="r_a948581a3ee983f757ccba4f4d67a43c3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a948581a3ee983f757ccba4f4d67a43c3">at</a> (size_t index) const override</td></tr>
<tr class="memdesc:a948581a3ee983f757ccba4f4d67a43c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds-checked access to the computational point at a specific index. Read only.  <br /></td></tr>
<tr class="memitem:a587524ec22ac2ad74674d65d40ec1efb" id="r_a587524ec22ac2ad74674d65d40ec1efb"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a587524ec22ac2ad74674d65d40ec1efb">at</a> (size_t index) override</td></tr>
<tr class="memdesc:a587524ec22ac2ad74674d65d40ec1efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds-checked access to the computational point at a specific index.  <br /></td></tr>
<tr class="memitem:aa1a6ed3318cdf765ef8abd58950671f3" id="r_aa1a6ed3318cdf765ef8abd58950671f3"><td class="memTemplParams" colspan="2">template&lt;SpacingFunction&lt; T &gt; Spacing&gt; </td></tr>
<tr class="memitem:aa1a6ed3318cdf765ef8abd58950671f3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a6ed3318cdf765ef8abd58950671f3">initialize_with_custom_spacing</a> (Spacing &amp;&amp;spacing_func)</td></tr>
<tr class="memdesc:aa1a6ed3318cdf765ef8abd58950671f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the mesh with custom spacing.  <br /></td></tr>
<tr class="memitem:a9552c0d7ebd508f691548b74c58a21cd" id="r_a9552c0d7ebd508f691548b74c58a21cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9552c0d7ebd508f691548b74c58a21cd">initialize_mesh</a> () override</td></tr>
<tr class="memdesc:a9552c0d7ebd508f691548b74c58a21cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the mesh the mesh by filling x_comp with the default spacing (see note).  <br /></td></tr>
<tr class="inherit_header pub_methods_class_bgk_1_1_base_mesh1_d"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_bgk_1_1_base_mesh1_d')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="class_bgk_1_1_base_mesh1_d.html">Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;</a></td></tr>
<tr class="memitem:af56eac6653810b45869aa2a65b0c26fc inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_af56eac6653810b45869aa2a65b0c26fc"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate_mesh</b> () const</td></tr>
<tr class="memitem:a676704748bde668d2e8135499029176b inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a676704748bde668d2e8135499029176b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bgk_1_1_base_mesh1_d.html#a676704748bde668d2e8135499029176b">reset_mesh</a> ()</td></tr>
<tr class="memdesc:a676704748bde668d2e8135499029176b inherit pub_methods_class_bgk_1_1_base_mesh1_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the mesh components and initialization status.  <br /></td></tr>
<tr class="memitem:a6407c4814ca0d854a3dbb82427d78e22 inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a6407c4814ca0d854a3dbb82427d78e22"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> () const</td></tr>
<tr class="memdesc:a6407c4814ca0d854a3dbb82427d78e22 inherit pub_methods_class_bgk_1_1_base_mesh1_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean indicating whether the mesh is initialized. <br /></td></tr>
<tr class="memitem:a1eaa852eb6202e00921305a7c21b997d inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a1eaa852eb6202e00921305a7c21b997d"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isConstructed</b> () const</td></tr>
<tr class="memdesc:a1eaa852eb6202e00921305a7c21b997d inherit pub_methods_class_bgk_1_1_base_mesh1_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean indicating whether the mesh is constructed. <br /></td></tr>
<tr class="memitem:a88f86084c9f88302b40798d06b39dc2b inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a88f86084c9f88302b40798d06b39dc2b"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_N</b> () const</td></tr>
<tr class="memitem:a09c22bc66017b27331c1594db2f5bd68 inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a09c22bc66017b27331c1594db2f5bd68"><td class="memItemLeft" align="right" valign="top">
const Container &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_XComp</b> () const</td></tr>
<tr class="memitem:a44b0d8f74527a39077129eb65dfa083e inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a44b0d8f74527a39077129eb65dfa083e"><td class="memItemLeft" align="right" valign="top">
auto&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="memitem:a2e262a020e8cb9e9325e9b1d8f8e2b0a inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_a2e262a020e8cb9e9325e9b1d8f8e2b0a"><td class="memItemLeft" align="right" valign="top">
auto&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memitem:ab7e08e23a93eac8cadef747b19a8008a inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_ab7e08e23a93eac8cadef747b19a8008a"><td class="memItemLeft" align="right" valign="top">
auto&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memitem:abfe5e5c7ff642803bb41f5a5d0a854a4 inherit pub_methods_class_bgk_1_1_base_mesh1_d" id="r_abfe5e5c7ff642803bb41f5a5d0a854a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bgk_1_1_base_mesh1_d.html#abfe5e5c7ff642803bb41f5a5d0a854a4">write_mesh_txt</a> (const std::string &amp;folder_name) const</td></tr>
<tr class="memdesc:abfe5e5c7ff642803bb41f5a5d0a854a4 inherit pub_methods_class_bgk_1_1_base_mesh1_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the mesh to a text file.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a75522e5bbdfe44154dc7742a1f8319b8" id="r_a75522e5bbdfe44154dc7742a1f8319b8"><td class="memItemLeft" align="right" valign="top"><a id="a75522e5bbdfe44154dc7742a1f8319b8" name="a75522e5bbdfe44154dc7742a1f8319b8"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>a1</b></td></tr>
<tr class="memitem:a0dd2ad53dc6667edfb8b83651c871621" id="r_a0dd2ad53dc6667edfb8b83651c871621"><td class="memItemLeft" align="right" valign="top"><a id="a0dd2ad53dc6667edfb8b83651c871621" name="a0dd2ad53dc6667edfb8b83651c871621"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>a2</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_bgk_1_1_base_mesh1_d"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_bgk_1_1_base_mesh1_d')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Attributes inherited from <a class="el" href="class_bgk_1_1_base_mesh1_d.html">Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;</a></td></tr>
<tr class="memitem:af6c2b3306221f8c234a62282e184305d inherit pro_attribs_class_bgk_1_1_base_mesh1_d" id="r_af6c2b3306221f8c234a62282e184305d"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>N</b></td></tr>
<tr class="memitem:a9d6fc52fdb029dcf1e5b6c0947846c56 inherit pro_attribs_class_bgk_1_1_base_mesh1_d" id="r_a9d6fc52fdb029dcf1e5b6c0947846c56"><td class="memItemLeft" align="right" valign="top">
Container&#160;</td><td class="memItemRight" valign="bottom"><b>x_comp</b></td></tr>
<tr class="memitem:a774a65b4060db00534ccd0af915a0e68 inherit pro_attribs_class_bgk_1_1_base_mesh1_d" id="r_a774a65b4060db00534ccd0af915a0e68"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_initialized</b></td></tr>
<tr class="memitem:a9b45cc8dc4d614867a38e6f7e4c27bc2 inherit pro_attribs_class_bgk_1_1_base_mesh1_d" id="r_a9b45cc8dc4d614867a38e6f7e4c27bc2"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_constructed</b></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a948581a3ee983f757ccba4f4d67a43c3" name="a948581a3ee983f757ccba4f4d67a43c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948581a3ee983f757ccba4f4d67a43c3">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds-checked access to the computational point at a specific index. Read only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the computational point to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computational point at the specified index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is greater than 2 * N + 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method provides safe access with bounds checking, unlike operator[]. </dd></dl>

<p>Reimplemented from <a class="el" href="class_bgk_1_1_base_mesh1_d.html#a7f80cd5f5f7ce728ec2833cb9da055d5">Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;</a>.</p>

</div>
</div>
<a id="a587524ec22ac2ad74674d65d40ec1efb" name="a587524ec22ac2ad74674d65d40ec1efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587524ec22ac2ad74674d65d40ec1efb">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds-checked access to the computational point at a specific index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the computational point to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the computational point at the specified index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is greater than 2 * N + 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method provides safe access with bounds checking, unlike operator[].</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9552c0d7ebd508f691548b74c58a21cd" name="a9552c0d7ebd508f691548b74c58a21cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9552c0d7ebd508f691548b74c58a21cd">&#9670;&#160;</a></span>initialize_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::initialize_mesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the mesh the mesh by filling x_comp with the default spacing (see note). </p>
<p>This method computes the computational points based on the configuration data calling initialize_with_custom_spacing. It uses the polynomial spacing following the schedule defined in the note</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the VelocityMeshFV object is not constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The mesh is initialized with the following formula <b>[aoki1990numerical:]</b>   <p class="formulaDsp">
\begin{align*}      zeta_j = a_1 \cdot j + a_2 \cdot j^3, \quad j = -2\overline{N}\dots,2\overline{N} \\
\end{align*}
</p>
 </dd></dl>

<p>Implements <a class="el" href="class_bgk_1_1_base_mesh1_d.html">Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;</a>.</p>

</div>
</div>
<a id="aa1a6ed3318cdf765ef8abd58950671f3" name="aa1a6ed3318cdf765ef8abd58950671f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a6ed3318cdf765ef8abd58950671f3">&#9670;&#160;</a></span>initialize_with_custom_spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;SpacingFunction&lt; T &gt; Spacing&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::initialize_with_custom_spacing </td>
          <td>(</td>
          <td class="paramtype">Spacing &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>spacing_func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the mesh with custom spacing. </p>
<p>This method allows the user to define a custom spacing function for the mesh then the computational points are computed based on the configuration data. The mesh is symmetric around zero, with points at negative indices mirroring those at positive indices; the spacing is supposed to be defined for the positive indices only.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpacingFunc</td><td>A callable type that takes an integer index and returns a T value representing the spacing at that index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spacing_func</td><td>A callable object that defines the custom spacing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method relies on universal references to allow for flexibility in the type of spacing function provided. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the VelocityMeshFV object is not constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43786842224f451a3e4e0277082968f" name="ac43786842224f451a3e4e0277082968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43786842224f451a3e4e0277082968f">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator to get the computational point at a specific index. Read only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the computational point to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computational point at the specified index.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>index must be within the dimension of the mesh (&lt;= 2 * N + 1). </dd></dl>

<p>Reimplemented from <a class="el" href="class_bgk_1_1_base_mesh1_d.html#a456e8e8eb6ff1c9c144b658e8164e19d">Bgk::BaseMesh1D&lt; T, std::vector&lt; T &gt;, MeshNature::VELOCITY &gt;</a>.</p>

</div>
</div>
<a id="ae4b70376cac02434c6d5670d7ee18dc2" name="ae4b70376cac02434c6d5670d7ee18dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b70376cac02434c6d5670d7ee18dc2">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_bgk_1_1_velocity_mesh.html">Bgk::VelocityMesh</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator to get the computational point at a specific index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the computational point to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computational point at the specified index.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>index must be within the dimension of the mesh (&lt;= 2 * N + 1).</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/andrearella/Desktop/Plasma_BGK/include/<a class="el" href="_velocity_mesh_8hpp_source.html">VelocityMesh.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Bgk</b></li><li class="navelem"><a href="class_bgk_1_1_velocity_mesh.html">VelocityMesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
